using System;
using System.Linq;
using System.Collections.Generic;

using Karen90MmoFramework.Quantum;
using Karen90MmoFramework.Server.Data;
using Karen90MmoFramework.Server.Game.Objects;

namespace Karen90MmoFramework.Server.Game.Systems
{
	/// <summary>
	/// A(n) <see cref="FixedLootContainer"/> will always generate the same loot for everyone who loots it.
	/// The loots for each looters have to be manually generated by calling <see cref="GenerateLootFor(Player)"/>.
	/// All loots are personalized, meaning looters will get their own individual copy of loot items regardless of who else is looting.
	/// </summary>
	public class FixedLootContainer : ILootContainer
	{
		#region Constants and Fields

		private readonly MmoObject owner;
		private readonly LootItem[] lootItems;
		private readonly Func<short, Player, bool> itemFilter;
		private readonly Dictionary<MmoGuid, Loot> playerLoots;

		private readonly Action<Player> lootAddedCallback;
		private readonly Action<Player> lootRemovedCallback;
		
		#endregion

		#region Constructors and Destructors
		 
		/// <summary>
		/// Creates a new instance of the <see cref="FixedLootContainer"/> class.
		/// </summary>
		public FixedLootContainer(MmoObject owner, short lootGroupId, Func<short, Player, bool> itemFilter, Action<Player> lootAddedCallback = null, Action<Player> lootRemovedCallback = null)
		{
			this.owner = owner;
			this.itemFilter = itemFilter;
			
			this.lootAddedCallback = lootAddedCallback;
			this.lootRemovedCallback = lootRemovedCallback;

			this.playerLoots = new Dictionary<MmoGuid, Loot>();
			// generating the intial loot which will be fixed
			this.lootItems = GenerateLoot(lootGroupId);
		}

		#endregion

		#region Implementation of ILootContainer

		/// <summary>
		/// Generates loot for (n)n <see cref="Player"/>.
		/// </summary>
		public void GenerateLootFor(Player player)
		{
			// if there is a personal loot available for the player then return
			if (playerLoots.ContainsKey(player.Guid))
				return;
			// looping thru the main loot to see if the player can loot any of the items
			// if the player cannot loot any of the item in the list return null
			if (!lootItems.Any(lootItem => itemFilter(lootItem.ItemId, player)))
				return;
			// create a copy of all the loot items
			var playerItems = lootItems.ToArray();
			for (var i = 0; i < playerItems.Length; i++)
			{
				var playerItem = playerItems[i];
				// if the item is already marked looted skip the item
				// this will usually happen when the loot does not generate any gold since gold will always remain at index 0 we need to manually skip it
				if(playerItem.IsLooted)
					continue;
				// if the player cannot loot the item mark it looted and skip
				if (!itemFilter(playerItem.ItemId, player))
				{
					// since the item is a struct we need to re-index the item to set the value
					playerItems[i].IsLooted = true;
					continue;
				}
				// if the player can loot the item mark it un-looted
				// since the item is a struct we need to re-index the item to set the value
				playerItems[i].IsLooted = false;
			}
			this.AddLoot(player, playerItems);
		}

		/// <summary>
		/// Tells whether the player has any loots
		/// </summary>
		public bool HasLootFor(Player player)
		{
			Loot loot;
			// does the player has any loot in the container?
			if (playerLoots.TryGetValue(player.Guid, out loot) == false)
				return false;

			var items = loot.LootItems;
			// looping thru all the player's loot to see if he or she has an unlooted item
			for (var i = 0; i < items.Length; i++)
			{
				// if any item is un-looted the looter has loot
				if (!items[i].IsLooted)
					return true;
			}
			// the player has looted all the loot items
			return false;
		}

		/// <summary>
		/// Returns the loot for a certain <see cref="Player"/> or null if the <see cref="Player"/> does not have any loot.
		/// </summary>
		public ILoot GetLootFor(Player player)
		{
			Loot loot;
			// it will contain the loot for the player or empty loot if the player does not have any
			return this.playerLoots.TryGetValue(player.Guid, out loot) ? loot : EmptyLootContainer.EmptyLoot;
		}

		/// <summary>
		/// Removes any generated loot for a certain <see cref="Player"/>.
		/// </summary>
		/// <param name="player"></param>
		public void RemoveLootFor(Player player)
		{
			// remove the loot
			this.playerLoots.Remove(player.Guid);
		}

		/// <summary>
		/// Clear all generated loots
		/// </summary>
		public void Clear()
		{
			this.playerLoots.Clear();
		}

		#endregion

		#region Public Methods

		/// <summary>
		/// Notifies looters of the loot availability
		/// </summary>
		public void NotifyLooters()
		{
			foreach (var pair in playerLoots)
			{
				MmoObject player;
				// the player is in the world?
				if (!owner.CurrentZone.ObjectCache.TryGetItem(pair.Key, out player))
					continue;
				// if the player is in the world
				// notify him or her of their loot
				var pl = player as Player;
				if (pl != null)
					pl.NotifyLoot(this.owner);
			}
		}

		#endregion

		#region Local Methods

		/// <summary>
		/// Generates loot items
		/// </summary>
		static LootItem[] GenerateLoot(short lootGroupId)
		{
			LootGroupData lootGroupData;
			if (!MmoWorld.Instance.ItemCache.TryGetLootGroupData(lootGroupId, out lootGroupData))
			{
				// cannot find loot group. write to logger
				Utils.Logger.ErrorFormat("[GenerateLoot]: LootGroup (Id={0}) cannot be found", lootGroupId);
				return null;
			}

			LootItem[] generatedLootItems = null;
			var possibleLootItems = lootGroupData.LootItems;
			// choose the lowest possible + 1 (for money)
			var maxLootSize = 1 + Mathf.Min(possibleLootItems.Length, ServerGameSettings.MAX_ITEMS_PER_LOOT);
			var addedCount = 0;
			// only generate gold if the chance is greater than 0
			if(lootGroupData.GoldChance > 0)
			{
				// generating a chance
				var chance = (float) Utils.Rnd.NextDouble() * 100;
				if (chance <= lootGroupData.GoldChance)
				{
					// randomly choose between min and max gold
					// remember to do this before generating any items
					// because the gold will always be at index 1 whether its generated or not
					var gold = Utils.Rnd.Next(lootGroupData.MinGold, lootGroupData.MaxGold);
					if (gold > 0)
					{
						// only create the array if we have atleast one loot item
						generatedLootItems = new LootItem[maxLootSize];
						// adding the gold item
						generatedLootItems[addedCount++ /* 0 */] = new LootItem(gold);
					}
				}
			}

			for (var i = 0; i < possibleLootItems.Length && addedCount < maxLootSize; i++)
			{
				var lootItem = possibleLootItems[i];
				// if the drop chance is invalid skip the item
				if (lootItem.DropChance <= 0)
					continue;
				// generating a chance
				var chance = (float)Utils.Rnd.NextDouble() * 100;
				// skip if the chance is greater
				if (chance > lootItem.DropChance)
					continue;
				// if the loot array hasnt been created yet create it
				if (generatedLootItems == null)
				{
					// only create the array if we have atleast one loot item
					generatedLootItems = new LootItem[maxLootSize];
					// if we havent already created the loot array
					// the first spot wont be there but we need it to contain gold spot whether its generated or not
					// setting it to 0 and marking it looted will let the loot skip it
					generatedLootItems[addedCount++ /* 0 */] = new LootItem(0) { IsLooted = true };
				}

				// adding the actual loot item
				generatedLootItems[addedCount++] = new LootItem(lootItem);
			}

			// we added atleast one item ?
			if (addedCount > 0 && generatedLootItems != null)
			{
				// resizes the array to total items size
				// this way we can eliminate empty slots and save overhead of sending the whole array to the client
				if (addedCount < generatedLootItems.Length)
					Array.Resize(ref generatedLootItems, addedCount);

				// set the loot
				return generatedLootItems;
			}
			// return an empty loot container if they are no loot generated
			return new LootItem[0];
		}

		/// <summary>
		/// Adds loot for a looter
		/// </summary>
		void AddLoot(Player player, LootItem[] lootToAdd)
		{
			var playerGuid = player.Guid;
			// only add if the player doesnt already have loot
			if (!playerLoots.ContainsKey(playerGuid))
			{
				playerLoots.Add(playerGuid, new Loot(this, lootToAdd));
				// invoke the loot added event
				if (lootAddedCallback != null)
					lootAddedCallback(player);
			}
		}

		/// <summary>
		/// Removes loot for a looter
		/// </summary>
		void RemoveLoot(Player player)
		{
			// remove the loot
			if(playerLoots.Remove(player.Guid))
			{
				// invoke the loot removed event
				if (lootRemovedCallback != null)
					lootRemovedCallback(player);
			}
		}

		#endregion

		#region class Loot : ILoot
		class Loot : ILoot
		{
			#region Constants and Fields

			/// <summary>
			/// the loot container
			/// </summary>
			private readonly FixedLootContainer lootContainer;

			/// <summary>
			/// loot items
			/// </summary>
			private readonly LootItem[] lootItems;

			#endregion

			#region Properties

			/// <summary>
			/// Gets the loot items
			/// First index will ALWAYS contain GOLD.
			/// </summary>
			public LootItem[] LootItems
			{
				get
				{
					return this.lootItems;
				}
			}

			#endregion

			#region Constructors and Destructors

			/// <summary>
			/// Creates a new <see cref="Loot"/>.
			/// </summary>
			public Loot(FixedLootContainer lootContainer, LootItem[] lootItems)
			{
				this.lootContainer = lootContainer;
				this.lootItems = lootItems;
			}

			#endregion

			#region Implementation of ILoot

			/// <summary>
			/// Determines whether the loot contains a certain item
			/// </summary>
			public bool HasItem(short itemId)
			{
				// searching for the item in our collection
				for (var i = 0; i < lootItems.Length; i++)
				{
					// if the item is found return if the item is unlooted
					var lootItem = lootItems[i];
					if (lootItem.ItemId == itemId)
						return !lootItem.IsLooted;
				}
				return false;
			}

			/// <summary>
			/// Collects a <see cref="LootItem"/> from an index and notifies the looters
			/// </summary>
			public void CollectLootItem(int index, Player collector)
			{
				// player trying to loot outside the loot range
				// possible hacking attempt
				if (index >= lootItems.Length)
					return;
				// if the item is already looted return
				var lootItem = lootItems[index];
				if (lootItem.IsLooted)
					return;
				// if the gold is 0 or the id is 0
				// its an invalid item or gold, return
				if (lootItem.CountOrGold <= 0)
					return;
				// remember the gold always sits in the 0th index
				// depending on the index loot gold or item
				if (index == 0)
					collector.GainGold(lootItem.CountOrGold, true);
				else
				{
					// add the item to the inventory
					InventoryOperationResult result;
					var added = collector.Inventory.AddItem(lootItem.ItemId, (byte) lootItem.CountOrGold, out result);
					// if it cannot be looted then return
					if (result == InventoryOperationResult.Fail || result == InventoryOperationResult.NoAdditionDueToSpace)
						return;
					// if we didnt fully add the item?
					if (result == InventoryOperationResult.PartialAdditionDueToSpace)
					{
						// update the item count
						lootItems[index] = new LootItem(lootItem.ItemId, (byte)(lootItem.CountOrGold - added));
						return;
					}
				}
				// notify the looter that he or she has taken the loot item
				collector.NotifyLootItemTakenFor(lootContainer.owner, index);
				// mark the item looted
				lootItems[index].IsLooted = true;
				// looping thru the items to see whether the player has looted all of his or her items or not
				for (var i = 0; i < lootItems.Length; i++)
				{
					// if there are items to be looted just return
					if (!lootItems[i].IsLooted)
						return;
				}
				// inform the collector to clear loot for the owner
				collector.NotifyLootClear(lootContainer.owner);
				// player has looted all the items so just delete the player
				this.lootContainer.RemoveLoot(collector);
			}

			/// <summary>
			/// Collects all the loot item and notifies the looter
			/// </summary>
			public void CollectAll(Player collector)
			{
				var collectedCount = 0;
				// adding items as a cluster rather than one by one
				// this will save us the overhead of sending items right after loot
				collector.BeginInventoryClusterAddition();

				var result = InventoryOperationResult.Success;
				for (var i = 0; i < lootItems.Length; i++)
				{
					var lootItem = lootItems[i];
					// if its already been looted ?
					if (lootItem.IsLooted)
						continue;
					// if the count is 0 there is nothing to loot
					if (lootItem.CountOrGold <= 0)
						continue;
					// at index 0 there is always gold
					if (i == 0)
						// loot the gold
						collector.GainGold(lootItem.CountOrGold, true);
					else
					{
						// add the item to the inventory
						var added = collector.Inventory.AddItem(lootItem.ItemId, (byte)lootItem.CountOrGold, out result);
						// if it cannot be looted then dont do anything
						if (result == InventoryOperationResult.Fail || result == InventoryOperationResult.NoAdditionDueToSpace)
							continue;
						// if we didnt fully add the item?
						if (result == InventoryOperationResult.PartialAdditionDueToSpace)
						{
							// update the item count
							lootItems[i] = new LootItem(lootItem.ItemId, (byte)(lootItem.CountOrGold - added));
							continue;
						}
					}
					// ok so we added the item completely
					// then mark it looted
					lootItems[i].IsLooted = true;
					collectedCount++;
				}
				// the loot may be empty only if they looted atleast one item
				if (collectedCount > 0)
				{
					var clearLoot = true;
					// looping thru the items to see whether the player has looted all of his or her items or not
					for (var i = 0; i < lootItems.Length; i++)
					{
						// if the item is looted, continue to the next item
						if (lootItems[i].IsLooted)
							continue;
						// making sure we dont clear all loot
						clearLoot = false;
						break;
					}
					// if we can clear all loot then, well, clear
					if (clearLoot)
					{
						// inform the collector to clear loot for the owner
						collector.NotifyLootClear(lootContainer.owner);
						// player has looted all the items so just delete the player
						this.lootContainer.RemoveLoot(collector);
					}
				}

				if (result != InventoryOperationResult.Success)
				{
					// we didnt loot all items on a CollectAll call
					// so report appropriate error
					// TODO: Report appropriate error
#if MMO_DEBUG
					Utils.Logger.InfoFormat("Loot.CollectAll({0}). {1}.", collector.Name, result);
#endif
				}
				//sending the cluster if there are any items added to it
				collector.EndInventoryClusterAddition();
			}

			#endregion
		}
		#endregion
	}
}
